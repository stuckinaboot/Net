// SPDX-License-Identifier: MIT
pragma solidity >=0.8.17 .0;

import {IRenderer} from "./IRenderer.sol";
import {TwoStepOwnable} from "./TwoStepOwnable.sol";
import {Net} from "../net/Net.sol";
import {EventsAndErrors} from "./EventsAndErrors.sol";
import {IERC721} from "@openzeppelin/contracts/interfaces/IERC721.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
import {ERC721A} from "@erc721a/ERC721A.sol";
import {Utils} from "./Utils.sol";

// TODO come up with new name beyond renderer maybe?
// TODO should name/pfp be here?

/// @title Renderer
/// @author Aspyn Palatnick (aspyn.eth, stuckinaboot.eth)
contract Renderer is ERC721A, EventsAndErrors, TwoStepOwnable {
    mapping(address nftAddress => address renderer)
        public supportedNftRenderers;
    mapping(address user => string name) public userToName;

    struct PFP {
        address tokenAddress;
        uint256 tokenId;
    }

    mapping(address user => PFP pfp) public userToPFP;

    uint256 constant NUM_MESSAGES_TO_FETCH = 1000;
    uint256 constant MAX_MESSAGE_BYTES_LENGTH = 250;

    Net willieNet;

    constructor(address willieNetAddr) ERC721A("Test renderer", "RDR") {
        willieNet = Net(willieNetAddr);
    }

    function _startTokenId() internal pure override returns (uint256) {
        return 1;
    }

    function mint(uint8 amount) external {
        // TODO consider supply cap

        _mint(msg.sender, amount);
    }

    function _passesUserStateChecks(
        address tokenAddress,
        uint256 tokenId
    ) internal view {
        // Validate renderer supports token
        if (supportedNftRenderers[tokenAddress] == address(0)) {
            revert TokenNotSupported();
        }
        if (IERC721(tokenAddress).ownerOf(tokenId) != msg.sender) {
            revert UserNotTokenOwner();
        }
    }

    function setName(
        address tokenAddress,
        uint256 tokenId,
        string calldata name
    ) external onlyOwner {
        // Checks
        _passesUserStateChecks(tokenAddress, tokenId);

        // Update name
        userToName[msg.sender] = name;

        // Emit name updated event
        emit NameUpdated(msg.sender, tokenAddress, tokenId);
    }

    function setPfp(
        address tokenAddress,
        uint256 tokenId,
        address pfpTokenAddress,
        uint256 pfpTokenId
    ) external onlyOwner {
        // Checks
        _passesUserStateChecks(tokenAddress, tokenId);

        // Update pfp
        userToPFP[msg.sender] = PFP({
            tokenAddress: pfpTokenAddress,
            tokenId: pfpTokenId
        });

        // Emit pfp updated event
        emit PfpUpdated(msg.sender, tokenAddress, tokenId);
    }

    function setSupportedNFTAddress(
        address nftAddress,
        address renderer
    ) external onlyOwner {
        supportedNftRenderers[nftAddress] = renderer;
    }

    function getUserAttributesEncoded(
        address[] memory addresses
    ) public returns (string memory) {
        // NOTE: it's possible the output has duplicate entries which we are considering an acceptable tradeoff here

        // TODO addresses is generated by messages encoded which sees what messages are encountered

        // Output should be {"0x123...":["name","pfp svg string"],...}
        // TODO calculate
        uint256 idxInOutput = 0;
        // TODO figure out right numbers
        // Max output length = start curly bracket + (num addresses * (quote + address + quote + colon + start square
        // bracket + quote +
        // name + quote + comma + quote + pfp +
        // quote + end square bracket) + (num addresses - 1 commas) + end curly bracket
        // TODO add max name length (using 100 for now)
        // TODO add max svg length (using 50000, 50 kb, for now)
        bytes memory output = new bytes(
            1 +
                addresses.length *
                (1 + 42 + 1 + 1 + 1 + 1 + 100 + 1 + 1 + 1 + 50_000 + 1 + 1) +
                (addresses.length - 1) +
                1
        );
        output[idxInOutput++] = "{";

        uint256 idxInAddresses = 0;
        unchecked {
            while (idxInAddresses < addresses.length) {
                // TODO
                // Add comma if not first item in output
                if (idxInOutput > 1) {
                    output[idxInOutput++] = ",";
                }
                output[idxInOutput++] = '"';
                string memory addressString = Strings.toHexString(
                    uint160(addresses[idxInAddresses]),
                    20
                );
                for (uint256 i; i < bytes(addressString).length; ++i) {
                    output[idxInOutput] = bytes(addressString)[i];
                    ++idxInOutput;
                }
                output[idxInOutput++] = '"';
                output[idxInOutput++] = ":";
                output[idxInOutput++] = "[";

                // Add name
                output[idxInOutput++] = '"';
                for (
                    uint256 i;
                    i < bytes(userToName[addresses[idxInAddresses]]).length;
                    ++i
                ) {
                    output[idxInOutput] = bytes(
                        userToName[addresses[idxInAddresses]]
                    )[i];
                    ++idxInOutput;
                }
                output[idxInOutput++] = '"';
                output[idxInOutput++] = ",";

                // TODO add pfp
                // output[idxInOutput++] = '"';
                // for (uint256 i; i < bytes(userToPFP[addresses[idxInAddresses]]).length; ++i) {
                //     output[idxInOutput] = bytes(userToPFP[addresses[idxInAddresses]])[i];
                //     ++idxInOutput;
                // }
                // output[idxInOutput++] = '"';
                output[idxInOutput++] = "]";

                ++idxInAddresses;
            }
        }

        output[idxInOutput++] = "}";
        assembly {
            mstore(output, idxInOutput)
        }
        return string(output);
    }

    function getMessagesEncoded()
        public
        view
        returns (string memory, address[] memory)
    {
        // TODO remove duplicates of addresses

        // Output should be ["message1","sender1","topic1",...]

        // Get N most recent messages under 300 bytes
        uint16 totalMessagesRecordedInOutput = 0;
        uint256 messagesLengthFromWillienet = willieNet.getTotalMessagesCount();
        uint256 currIdxInMessagesFromWillienet = messagesLengthFromWillienet > 0
            ? messagesLengthFromWillienet - 1
            : messagesLengthFromWillienet; //TODO

        uint256 idxInOutput = 0;
        // Max output length = start and end bracket (2) + open and close quote for each message, sender, topic (3 * 2 *
        // NUM_MESSAGES_TO_FETCH) + comma between each message (NUM_MESSAGES_TO_FETCH - 1)
        // TODO this doesn't actually include message or topic length
        bytes memory output = new bytes(
            2 + 3 * 2 * NUM_MESSAGES_TO_FETCH + NUM_MESSAGES_TO_FETCH - 1
        ); // TODO total
        output[idxInOutput++] = "[";

        // At most NUM_MESSAGES_TO_FETCH addresses
        uint256 idxInAddresses = 0;
        address[] memory addresses = new address[](NUM_MESSAGES_TO_FETCH);

        // TODO can copy strings into bytes
        // https://coinsbench.com/solidity-strings-mrexamples-625b1784679b
        unchecked {
            while (
                totalMessagesRecordedInOutput < NUM_MESSAGES_TO_FETCH &&
                currIdxInMessagesFromWillienet >= 0
            ) {
                Net.Message memory message = willieNet.getMessage(
                    currIdxInMessagesFromWillienet
                );
                if (bytes(message.message).length < MAX_MESSAGE_BYTES_LENGTH) {
                    // TODO figure out if we want [ ] or { } or something for storing in JS
                    // Add comma and start quote
                    if (idxInOutput > 1) {
                        // Add comma if not first item in output
                        output[idxInOutput++] = ",";
                    }
                    output[idxInOutput++] = '"';

                    // Store message
                    for (uint256 i; i < bytes(message.message).length; ++i) {
                        output[idxInOutput] = bytes(message.message)[i];
                        ++idxInOutput;
                    }
                    // Add end quote
                    output[idxInOutput++] = '"';

                    // Store sender address
                    output[idxInOutput++] = ",";
                    output[idxInOutput++] = '"';

                    addresses[idxInAddresses++] = message.sender;
                    // TODO is this most optimal approach? https://ethereum.stackexchange.com/a/126160
                    string memory addressString = Strings.toHexString(
                        uint160(message.sender),
                        20
                    );
                    for (uint256 i; i < bytes(addressString).length; ++i) {
                        output[idxInOutput] = bytes(addressString)[i];
                        ++idxInOutput;
                    }
                    // Add end quote
                    output[idxInOutput++] = '"';

                    // Store topic
                    output[idxInOutput++] = ",";
                    output[idxInOutput++] = '"';
                    for (uint256 i; i < bytes(message.topic).length; ++i) {
                        output[idxInOutput] = bytes(message.topic)[i];
                        ++idxInOutput;
                    }
                    output[idxInOutput++] = '"';

                    ++totalMessagesRecordedInOutput;
                }
                if (currIdxInMessagesFromWillienet > 0) {
                    --currIdxInMessagesFromWillienet;
                } else {
                    // Final message reached, leave since no more messages to look at
                    break;
                }
            }
        }
        output[idxInOutput++] = "]";
        assembly {
            mstore(output, idxInOutput)
        }
        assembly {
            // TODO check if need to add one or if this fine
            mstore(addresses, idxInAddresses)
        }

        return (string(output), addresses);
    }

    function animationUrl() public view returns (string memory) {
        (string memory messagesEncoded, ) = getMessagesEncoded();
        return
            string.concat(
                '<html><body style="margin: 0"><svg id="root" viewBox="0 0 400 400" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="100%" height="100%" fill="rgba(0,0,0,1)" /></svg><script>',
                'function random_rgba(){return`hsl(${360*Math.random()},100%,60%)`}const images=["PHN2ZwogIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICB3aWR0aD0iMTAwJSIKICBoZWlnaHQ9IjEwMCUiCiAgdmlld0JveD0iMCAwIDQwMCA0MDAiCiAgc3R5bGU9ImJhY2tncm91bmQ6ICMwMDA7IGRpc3BsYXk6IGJsb2NrOyBtYXJnaW46IGF1dG8iCj4KICA8Y2lyY2xlIGN4PSIyMDAiIGN5PSIyMDAiIHI9IjE1MCIgc3Ryb2tlPSJyZWQiIHN0cm9rZS13aWR0aD0iMjUiPjwvY2lyY2xlPgo8L3N2Zz4K",],CONTENT_INTERVAL=3,contents=',
                messagesEncoded,
                '.reverse();let s=async t=>new Promise(e=>setTimeout(e,t));async function writeText(){let t=Array.from(document.getElementsByTagName("text")),e=t.map(t=>t.textContent);t.forEach(t=>t.textContent="");let n=Array.from(document.getElementsByTagName("image"));n.forEach(t=>t.setAttributeNS(null,"visibility","hidden"));for(let r=0;r<t.length;r++){let l=e[r];r%2==0&&n[r/2].setAttributeNS(null,"visibility","visible");for(let a=0;a<=l.length;a++)t[r].textContent=l.substring(0,a),await s(1)}}let SVG_HEIGHT=400,MSGS_TO_SHOW_AT_ONCE=18,START_MSGS_IDX=contents.length-3*MSGS_TO_SHOW_AT_ONCE;async function addElements(){let t=document.getElementById("root"),e=22,n=3,r=18,l=SVG_HEIGHT/MSGS_TO_SHOW_AT_ONCE,a=6;for(let o=START_MSGS_IDX;o<START_MSGS_IDX+3*MSGS_TO_SHOW_AT_ONCE&&o<contents.length;o+=3){let S="pink";if(o>=0){var c=document.createElementNS("http://www.w3.org/2000/svg","image");c.setAttributeNS(null,"height","300px"),c.setAttributeNS(null,"width","300px"),c.setAttributeNS(null,"transform",`translate(2,${n}) scale(0.05)`),c.setAttributeNS("http://www.w3.org/1999/xlink","href",`data:image/svg+xml;base64,${images[0]}`),t.append(c);var m=document.createElementNS("http://www.w3.org/2000/svg","line");m.setAttribute("x1","2"),m.setAttribute("x2","400"),m.setAttribute("y1",e),m.setAttribute("y2",e),m.setAttribute("stroke",S),m.setAttribute("stroke-width","0.3px"),t.append(m);let[$,A,g]=[contents[o],contents[o+1],contents[o+2]];var T=document.createElementNS("http://www.w3.org/2000/svg","text");T.setAttribute("style","font-family: monospace; font-size: 6px"),T.setAttribute("x","20"),T.setAttribute("y",a),T.setAttribute("fill",S),T.textContent=`<name> | ${g} | ${A}`,t.append(T);var u=document.createElementNS("http://www.w3.org/2000/svg","text");u.setAttribute("style","font-family: monospace; font-size: 9px"),u.setAttribute("x","20"),u.setAttribute("y",r),u.setAttribute("fill",S),u.textContent=$,t.append(u)}e+=l,r+=l,a+=l,n+=l}}function clear(t){Array.from(document.getElementsByTagName(t)).forEach(function(t){t.parentNode.removeChild(t)})}async function removeElements(){clear("image"),clear("text"),clear("line")}async function refresh(){await removeElements(),await addElements(),await writeText()}refresh();let cursorPoint=t=>{var e=document.getElementById("root").createSVGPoint();return e.x=t.clientX,e.y=t.clientY,e.matrixTransform(document.getElementById("root").getScreenCTM().inverse())};document.body.addEventListener("click",async t=>{t.target;let e=cursorPoint(t);console.log(e,document.getElementById("root").getAttribute("height"));let n=!1;e.y>SVG_HEIGHT/2?START_MSGS_IDX+MSGS_TO_SHOW_AT_ONCE<contents.length&&(START_MSGS_IDX+=MSGS_TO_SHOW_AT_ONCE,n=!0):START_MSGS_IDX>0&&(START_MSGS_IDX-=MSGS_TO_SHOW_AT_ONCE,n=!0),n&&await refresh()});',
                "</script></body></html>"
            );
    }

    /// @notice Get token uri for token.
    /// @param tokenId token id
    /// @return tokenURI
    function tokenURI(
        uint256 tokenId
    ) public view virtual override returns (string memory) {
        if (!_exists(tokenId)) {
            revert URIQueryForNonexistentToken();
        }

        string memory artSvg = "TODO";
        (string memory messagesEncoded, ) = getMessagesEncoded();

        return
            Utils.formatTokenURI(
                tokenId,
                // Red together ring
                "data:image/svg+xml;base64,PHN2ZwogIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICB3aWR0aD0iMTAwJSIKICBoZWlnaHQ9IjEwMCUiCiAgdmlld0JveD0iMCAwIDQwMCA0MDAiCiAgc3R5bGU9ImJhY2tncm91bmQ6ICMwMDA7IGRpc3BsYXk6IGJsb2NrOyBtYXJnaW46IGF1dG8iCj4KICA8Y2lyY2xlIGN4PSIyMDAiIGN5PSIyMDAiIHI9IjE1MCIgc3Ryb2tlPSJyZWQiIHN0cm9rZS13aWR0aD0iMjUiPjwvY2lyY2xlPgo8L3N2Zz4K",
                string.concat(
                    "data:text/html;base64,",
                    Utils.encodeBase64(bytes(animationUrl()))
                ),
                // Utils.encodeBase64(
                //     bytes(string.concat('<html style="overflow:hidden"><body style="margin:0">', "", "</body></html>"))
                // )
                "[]"
            );
    }

    function getArt(
        uint256 tokenId
    ) external returns (string memory svg, string memory html) {
        // Get messages
        (
            string memory messages,
            address[] memory addresses
        ) = getMessagesEncoded();

        // Get user attributes
        string memory userAttributes = getUserAttributesEncoded(addresses);

        // Generate html from messages and user attributes

        // TODO consider having a default svg for all, or maybe some very slight difference?
    }
}

{"language":"Solidity","sources":{"src/apps/inscribed-drops/InscribedDrops.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 .0;\n\nimport {Net} from \"../../net/Net.sol\";\nimport {ERC1155} from \"@solady/tokens/ERC1155.sol\";\nimport {Base64} from \"@solady/utils/Base64.sol\";\nimport {SafeTransferLib} from \"@solady/utils/SafeTransferLib.sol\";\nimport {TwoStepOwnable} from \"./TwoStepOwnable.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\n/// @title InscribedDrops\n/// @author Aspyn Palatnick (aspyn.eth, stuckinaboot.eth)\n/// @notice NFT mints created by inscribing token uris and mint configurations in Net messages.\ncontract InscribedDrops is ERC1155, TwoStepOwnable {\n    using LibString for uint256;\n\n    uint256 public totalDrops;\n    uint256 public feeBps = 500;\n    Net internal net = Net(0x00000000B24D62781dB359b07880a105cD0b64e6);\n\n    mapping(uint256 id => uint256 supply) public totalSupply;\n\n    mapping(uint256 id => mapping(address user => uint256 minted))\n        public mintedPerWallet;\n\n    error TokenDoesNotExist();\n    error TokenUriEmpty();\n    error MintPaymentIncorrect();\n    error MintSupplyReached();\n    error MaxMintsPerWalletReached();\n    error MintEndTimestampReached();\n    error CannotMintQuantityZero();\n\n    event InscribedDrop(address indexed creator, uint256 id);\n\n    string internal constant INSCRIBE_TOPIC = \"i\";\n    string internal constant MINT_TOPIC = \"m\";\n    string public constant NET_APP_NAME = \"Inscribed Drops\";\n\n    constructor() {\n        _transferOwnership(address(0xcf75Bf188c5CA5198eF571aed3D75ECDe3bcD9D9));\n    }\n\n    function name() external pure returns (string memory) {\n        return NET_APP_NAME;\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"NET\";\n    }\n\n    function inscribe(\n        uint256 mintPrice,\n        uint256 maxSupply,\n        uint256 mintEndTimestamp,\n        uint256 maxMintsPerWallet,\n        string calldata tokenUri\n    ) external {\n        // Check token uri non-empty\n        if (bytes(tokenUri).length == 0) {\n            revert TokenUriEmpty();\n        }\n\n        // Mint first token in drop\n        _mint(msg.sender, totalDrops, 1, \"\");\n        // Set total supply to 1\n        totalSupply[totalDrops] = 1;\n        // Set minted per wallet to 1\n        mintedPerWallet[totalDrops][msg.sender] = 1;\n        // Emit inscribed drop event\n        emit InscribedDrop(msg.sender, totalDrops);\n\n        // Increase total drops\n        unchecked {\n            ++totalDrops;\n        }\n\n        // Call Net to send message\n        net.sendMessageViaApp(\n            msg.sender,\n            tokenUri,\n            INSCRIBE_TOPIC,\n            abi.encode(\n                mintPrice,\n                maxSupply,\n                mintEndTimestamp,\n                maxMintsPerWallet\n            )\n        );\n    }\n\n    function setFeeBps(uint256 newFeeBps) external onlyOwner {\n        feeBps = newFeeBps;\n    }\n\n    function mint(uint256 id, uint256 quantity) external payable {\n        if (id >= totalDrops) {\n            revert TokenDoesNotExist();\n        }\n        if (quantity == 0) {\n            revert CannotMintQuantityZero();\n        }\n\n        // Get message\n        Net.Message memory message = net.getMessageForAppTopic(\n            id,\n            address(this),\n            INSCRIBE_TOPIC\n        );\n\n        // Parse data\n        (\n            uint256 mintPrice,\n            uint256 maxSupply,\n            uint256 mintEndTimestamp,\n            uint256 maxMintsPerWallet\n        ) = abi.decode(message.data, (uint256, uint256, uint256, uint256));\n\n        unchecked {\n            // Check payment correct, if non-zero\n            if (mintPrice != 0 && msg.value != mintPrice * quantity) {\n                revert MintPaymentIncorrect();\n            }\n\n            // Check supply not reached, if non-zero\n            if (maxSupply != 0 && totalSupply[id] + quantity > maxSupply) {\n                revert MintSupplyReached();\n            }\n\n            // Check max mints per wallet not reached, if non-zero\n            if (\n                maxMintsPerWallet != 0 &&\n                mintedPerWallet[id][msg.sender] + quantity > maxMintsPerWallet\n            ) {\n                revert MaxMintsPerWalletReached();\n            }\n        }\n\n        // Check mint not ended, if non-zero\n        if (mintEndTimestamp != 0 && block.timestamp > mintEndTimestamp) {\n            revert MintEndTimestampReached();\n        }\n\n        // Mint tokens\n        _mint(msg.sender, id, quantity, \"\");\n\n        unchecked {\n            // Update total supply\n            totalSupply[id] += quantity;\n\n            // Update minted per wallet\n            mintedPerWallet[id][msg.sender] += quantity;\n        }\n\n        // If owner is non-zero and fee is non-zero and msg value is non-zero, transfer fee\n        if (owner() != address(0) && feeBps != 0 && msg.value > 0) {\n            unchecked {\n                uint256 fee = (feeBps * msg.value) / 10_000;\n                // Transfer fee\n                SafeTransferLib.safeTransferETH(payable(owner()), fee);\n\n                // Transfer remainder to creator of drop\n                SafeTransferLib.safeTransferETH(\n                    message.sender,\n                    msg.value - fee\n                );\n            }\n        } else {\n            // Transfer full amount to creator of drop\n            SafeTransferLib.safeTransferETH(payable(message.sender), msg.value);\n        }\n\n        // Send mint message on Net\n        net.sendMessageViaApp(\n            msg.sender,\n            string.concat(\n                \"Minted \",\n                quantity.toString(),\n                \" of #\",\n                id.toString()\n            ),\n            MINT_TOPIC,\n            \"\"\n        );\n    }\n\n    function uri(uint256 id) public view override returns (string memory) {\n        if (id >= totalDrops) {\n            revert TokenDoesNotExist();\n        }\n\n        return\n            string.concat(\n                \"data:application/json;base64,\",\n                Base64.encode(\n                    bytes(\n                        net\n                            .getMessageForAppTopic(\n                                id,\n                                address(this),\n                                INSCRIBE_TOPIC\n                            )\n                            .text\n                    )\n                )\n            );\n    }\n}\n"},"src/net/Net.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 .0;\n\nimport {EventsAndErrors} from \"./EventsAndErrors.sol\";\nimport {INet} from \"./INet.sol\";\nimport {SSTORE2} from \"@solady/utils/SSTORE2.sol\";\n\n/// @title Net\n/// @author Aspyn Palatnick (aspyn.eth, stuckinaboot.eth)\n/// @notice Fully decentralized onchain messaging protocol\ncontract Net is INet, EventsAndErrors {\n    // Use a single global mapping to map hashes to message indexes\n    mapping(bytes32 hashVal => uint256[] messageIndexes)\n        public hashToMessageIndexes;\n\n    address[] public messagePointers;\n\n    bytes32 constant ZERO_HASH = keccak256(abi.encodePacked(address(0)));\n\n    // Empty topic \"\" will not impact a hash, which could result in collisions\n    // between hash values that use topic and don't use topic. For that reason,\n    // we prefix the relevant hash topic keys with these values to ensure collisions don't occur\n    // Example if this prefix didn't exist:\n    // keccak256(abi.encodePacked(address(0))) == keccak256(abi.encodePacked(address(0), \"\" /* where \"\" represents topic */)) evaluates to true\n    uint256 constant APP_TOPIC_HASH_PREFIX = 1;\n    uint256 constant APP_USER_TOPIC_HASH_PREFIX = 2;\n\n    // ************\n    // Send message\n    // ************\n\n    /// @notice Send message via app\n    /// @param sender message sender\n    /// @param text message text\n    /// @param topic message topic\n    /// @param data message data\n    function sendMessageViaApp(\n        address sender,\n        string calldata text,\n        string calldata topic,\n        bytes calldata data\n    ) external {\n        // Revert if message length is none to prevent empty messages\n        if (bytes(text).length == 0 && bytes(data).length == 0) {\n            revert MsgEmpty();\n        }\n\n        // Track message index in topic and user mappings\n        uint256 messagesLength = messagePointers.length;\n\n        // App messages\n        hashToMessageIndexes[keccak256(abi.encodePacked(msg.sender))].push(\n            messagesLength\n        );\n\n        // App-user messages\n        hashToMessageIndexes[keccak256(abi.encodePacked(msg.sender, sender))]\n            .push(messagesLength);\n\n        // App-topic messages\n        hashToMessageIndexes[\n            // msg.sender is the app id\n            keccak256(\n                abi.encodePacked(APP_TOPIC_HASH_PREFIX, msg.sender, topic)\n            )\n        ].push(messagesLength);\n\n        // App-user-topic messages\n        hashToMessageIndexes[\n            keccak256(\n                abi.encodePacked(\n                    APP_USER_TOPIC_HASH_PREFIX,\n                    msg.sender,\n                    sender,\n                    topic\n                )\n            )\n        ].push(messagesLength);\n\n        // Emit message sent using current messages length as the index\n        emit MessageSentViaApp(msg.sender, sender, topic, messagesLength);\n\n        // Store message\n        messagePointers.push(\n            SSTORE2.write(\n                abi.encode(\n                    // App\n                    msg.sender,\n                    // Sender\n                    sender,\n                    // Timestamp\n                    block.timestamp,\n                    // Data\n                    data,\n                    // Text\n                    text,\n                    // Topic\n                    topic\n                )\n            )\n        );\n    }\n\n    /// @notice Send message\n    /// @param text message text\n    /// @param topic message topic\n    /// @param data message data\n    function sendMessage(\n        string calldata text,\n        string calldata topic,\n        bytes calldata data\n    ) external {\n        // Revert if message length is none to prevent empty messages\n        if (bytes(text).length == 0 && bytes(data).length == 0) {\n            revert MsgEmpty();\n        }\n\n        // Track message index in topic and user mappings\n        uint256 messagesLength = messagePointers.length;\n\n        // address(0) is used to represent messages sent from \"no app\"\n        hashToMessageIndexes[ZERO_HASH].push(messagesLength);\n        hashToMessageIndexes[\n            keccak256(\n                abi.encodePacked(APP_TOPIC_HASH_PREFIX, address(0), topic)\n            )\n        ].push(messagesLength);\n        hashToMessageIndexes[\n            keccak256(abi.encodePacked(address(0), msg.sender))\n        ].push(messagesLength);\n        hashToMessageIndexes[\n            keccak256(\n                abi.encodePacked(\n                    APP_USER_TOPIC_HASH_PREFIX,\n                    address(0),\n                    msg.sender,\n                    topic\n                )\n            )\n        ].push(messagesLength);\n\n        // Emit message sent using current messages length as the index\n        emit MessageSent(msg.sender, topic, messagesLength);\n\n        // Store message\n        messagePointers.push(\n            SSTORE2.write(\n                abi.encode(\n                    // App\n                    address(0),\n                    // Sender\n                    msg.sender,\n                    // Timestamp\n                    block.timestamp,\n                    // Data\n                    data,\n                    // Text\n                    text,\n                    // Topic\n                    topic\n                )\n            )\n        );\n    }\n\n    // **************\n    // Fetch Messages\n    // **************\n\n    // Fetch message indexes\n\n    /// @notice Get message pointer index for app\n    /// @param idx message index\n    /// @param app app\n    /// @return index index\n    function getMessageIdxForApp(\n        uint256 idx,\n        address app\n    ) external view returns (uint256) {\n        return hashToMessageIndexes[keccak256(abi.encodePacked(app))][idx];\n    }\n\n    /// @notice Get message pointer index for app user\n    /// @param idx message index\n    /// @param app app\n    /// @param user user\n    /// @return index index\n    function getMessageIdxForAppUser(\n        uint256 idx,\n        address app,\n        address user\n    ) external view returns (uint256) {\n        return\n            hashToMessageIndexes[keccak256(abi.encodePacked(app, user))][idx];\n    }\n\n    /// @notice Get message pointer index for app topic\n    /// @param idx message index\n    /// @param app app\n    /// @param topic topic\n    /// @return index index\n    function getMessageIdxForAppTopic(\n        uint256 idx,\n        address app,\n        string calldata topic\n    ) external view returns (uint256) {\n        return\n            hashToMessageIndexes[\n                keccak256(abi.encodePacked(APP_TOPIC_HASH_PREFIX, app, topic))\n            ][idx];\n    }\n\n    /// @notice Get message pointer index for app user topic\n    /// @param idx message index\n    /// @param app app\n    /// @param user user\n    /// @param topic topic\n    /// @return index index\n    function getMessageIdxForAppUserTopic(\n        uint256 idx,\n        address app,\n        address user,\n        string calldata topic\n    ) external view returns (uint256) {\n        return\n            hashToMessageIndexes[\n                keccak256(\n                    abi.encodePacked(\n                        APP_USER_TOPIC_HASH_PREFIX,\n                        app,\n                        user,\n                        topic\n                    )\n                )\n            ][idx];\n    }\n\n    // Fetch single message\n\n    /// @notice Decode encoded message\n    /// @param encodedMessage encoded message\n    /// @return decodedMessage decoded message\n    function decodeMessage(\n        bytes memory encodedMessage\n    ) public pure returns (Message memory) {\n        Message memory message;\n        (\n            message.app,\n            message.sender,\n            message.timestamp,\n            message.data,\n            message.text,\n            message.topic\n        ) = abi.decode(\n            encodedMessage,\n            (\n                // App\n                address,\n                // Sender\n                address,\n                // Timestamp\n                uint256,\n                // Data\n                bytes,\n                // Text\n                string,\n                // Topic\n                string\n            )\n        );\n        return message;\n    }\n\n    /// @notice Decode message at index in message pointers\n    /// @param idx index\n    /// @return decodedMessage decoded message\n    function decodeMessageAtIndex(\n        uint256 idx\n    ) public view returns (Message memory) {\n        return decodeMessage(SSTORE2.read(messagePointers[idx]));\n    }\n\n    /// @notice Get message\n    /// @param idx index\n    /// @return message message\n    function getMessage(uint256 idx) external view returns (Message memory) {\n        return decodeMessageAtIndex(idx);\n    }\n\n    /// @notice Get message for app\n    /// @param idx index\n    /// @param app app\n    /// @return message message\n    function getMessageForApp(\n        uint256 idx,\n        address app\n    ) external view returns (Message memory) {\n        return\n            decodeMessageAtIndex(\n                hashToMessageIndexes[keccak256(abi.encodePacked(app))][idx]\n            );\n    }\n\n    /// @notice Get message for app user\n    /// @param idx index\n    /// @param app app\n    /// @param user user\n    /// @return message message\n    function getMessageForAppUser(\n        uint256 idx,\n        address app,\n        address user\n    ) external view returns (Message memory) {\n        return\n            decodeMessageAtIndex(\n                hashToMessageIndexes[keccak256(abi.encodePacked(app, user))][\n                    idx\n                ]\n            );\n    }\n\n    /// @notice Get message for app topic\n    /// @param idx index\n    /// @param app app\n    /// @param topic topic\n    /// @return message message\n    function getMessageForAppTopic(\n        uint256 idx,\n        address app,\n        string calldata topic\n    ) external view returns (Message memory) {\n        return\n            decodeMessageAtIndex(\n                hashToMessageIndexes[\n                    keccak256(\n                        abi.encodePacked(APP_TOPIC_HASH_PREFIX, app, topic)\n                    )\n                ][idx]\n            );\n    }\n\n    /// @notice Get message for app user topic\n    /// @param idx index\n    /// @param app app\n    /// @param user user\n    /// @param topic topic\n    /// @return message message\n    function getMessageForAppUserTopic(\n        uint256 idx,\n        address app,\n        address user,\n        string calldata topic\n    ) external view returns (Message memory) {\n        return\n            decodeMessageAtIndex(\n                hashToMessageIndexes[\n                    keccak256(\n                        abi.encodePacked(\n                            APP_USER_TOPIC_HASH_PREFIX,\n                            app,\n                            user,\n                            topic\n                        )\n                    )\n                ][idx]\n            );\n    }\n\n    // Fetch multiple messages\n\n    /// @notice Get messages in range\n    /// @param startIdx start index\n    /// @param endIdx end index\n    /// @return messages list of messages\n    function getMessagesInRange(\n        uint256 startIdx,\n        uint256 endIdx\n    ) external view returns (Message[] memory) {\n        if (startIdx >= endIdx) {\n            revert InvalidRange();\n        }\n        uint256 querySetLength = messagePointers.length;\n        if (startIdx + 1 > querySetLength) {\n            revert InvalidStartIndex();\n        }\n        if (endIdx > querySetLength) {\n            revert InvalidEndIndex();\n        }\n\n        Message[] memory messagesSlice = new Message[](endIdx - startIdx);\n        uint256 idxInMessages = startIdx;\n        unchecked {\n            for (; idxInMessages < endIdx; ) {\n                messagesSlice[idxInMessages - startIdx] = decodeMessageAtIndex(\n                    idxInMessages\n                );\n                ++idxInMessages;\n            }\n        }\n\n        return messagesSlice;\n    }\n\n    /// @notice Get messages in range for hash\n    /// @param startIdx start index\n    /// @param endIdx end index\n    /// @param hashVal hash\n    /// @return messages list of messages\n    function getMessagesInRangeForHash(\n        uint256 startIdx,\n        uint256 endIdx,\n        bytes32 hashVal\n    ) public view returns (Message[] memory) {\n        if (startIdx >= endIdx) {\n            revert InvalidRange();\n        }\n        uint256 querySetLength = hashToMessageIndexes[hashVal].length;\n        if (startIdx + 1 > querySetLength) {\n            revert InvalidStartIndex();\n        }\n        if (endIdx > querySetLength) {\n            revert InvalidEndIndex();\n        }\n\n        Message[] memory messagesSlice = new Message[](endIdx - startIdx);\n        uint256 idxInMessages = startIdx;\n        unchecked {\n            for (; idxInMessages < endIdx; ) {\n                messagesSlice[idxInMessages - startIdx] = decodeMessageAtIndex(\n                    hashToMessageIndexes[hashVal][idxInMessages]\n                );\n                ++idxInMessages;\n            }\n        }\n\n        return messagesSlice;\n    }\n\n    /// @notice Get messages in range for app\n    /// @param startIdx start index\n    /// @param endIdx end index\n    /// @param app app\n    /// @return messages list of messages\n    function getMessagesInRangeForApp(\n        uint256 startIdx,\n        uint256 endIdx,\n        address app\n    ) external view returns (Message[] memory) {\n        return\n            getMessagesInRangeForHash(\n                startIdx,\n                endIdx,\n                keccak256(abi.encodePacked(app))\n            );\n    }\n\n    /// @notice Get messages in range for app user\n    /// @param startIdx start index\n    /// @param endIdx end index\n    /// @param app app\n    /// @param user user\n    /// @return messages list of messages\n    function getMessagesInRangeForAppUser(\n        uint256 startIdx,\n        uint256 endIdx,\n        address app,\n        address user\n    ) external view returns (Message[] memory) {\n        return\n            getMessagesInRangeForHash(\n                startIdx,\n                endIdx,\n                keccak256(abi.encodePacked(app, user))\n            );\n    }\n\n    /// @notice Get messages in range for app topic\n    /// @param startIdx start index\n    /// @param endIdx end index\n    /// @param app app\n    /// @param topic topic\n    /// @return messages list of messages\n    function getMessagesInRangeForAppTopic(\n        uint256 startIdx,\n        uint256 endIdx,\n        address app,\n        string calldata topic\n    ) external view returns (Message[] memory) {\n        return\n            getMessagesInRangeForHash(\n                startIdx,\n                endIdx,\n                keccak256(abi.encodePacked(APP_TOPIC_HASH_PREFIX, app, topic))\n            );\n    }\n\n    /// @notice Get messages in range for app user topic\n    /// @param startIdx start index\n    /// @param endIdx end index\n    /// @param app app\n    /// @param user user\n    /// @param topic topic\n    /// @return messages list of messages\n    function getMessagesInRangeForAppUserTopic(\n        uint256 startIdx,\n        uint256 endIdx,\n        address app,\n        address user,\n        string calldata topic\n    ) external view returns (Message[] memory) {\n        return\n            getMessagesInRangeForHash(\n                startIdx,\n                endIdx,\n                keccak256(\n                    abi.encodePacked(\n                        APP_USER_TOPIC_HASH_PREFIX,\n                        app,\n                        user,\n                        topic\n                    )\n                )\n            );\n    }\n\n    // **************\n    // Message counts\n    // **************\n\n    /// @notice Get total messages count\n    /// @return count count\n    function getTotalMessagesCount() external view returns (uint256) {\n        return messagePointers.length;\n    }\n\n    /// @notice Get total messages for hash count\n    /// @param hashVal hash\n    /// @return count count\n    function getTotalMessagesForHashCount(\n        bytes32 hashVal\n    ) public view returns (uint256) {\n        return hashToMessageIndexes[hashVal].length;\n    }\n\n    /// @notice Get total messages for app count\n    /// @param app app\n    /// @return count count\n    function getTotalMessagesForAppCount(\n        address app\n    ) external view returns (uint256) {\n        return getTotalMessagesForHashCount(keccak256(abi.encodePacked(app)));\n    }\n\n    /// @notice Get total messages for app user count\n    /// @param app app\n    /// @param user user\n    /// @return count count\n    function getTotalMessagesForAppUserCount(\n        address app,\n        address user\n    ) external view returns (uint256) {\n        return\n            getTotalMessagesForHashCount(\n                keccak256(abi.encodePacked(app, user))\n            );\n    }\n\n    /// @notice Get total messages for app topic count\n    /// @param app app\n    /// @param topic topic\n    /// @return count count\n    function getTotalMessagesForAppTopicCount(\n        address app,\n        string calldata topic\n    ) external view returns (uint256) {\n        return\n            getTotalMessagesForHashCount(\n                keccak256(abi.encodePacked(APP_TOPIC_HASH_PREFIX, app, topic))\n            );\n    }\n\n    /// @notice Get total messages for app user topic count\n    /// @param app app\n    /// @param user user\n    /// @param topic topic\n    /// @return count count\n    function getTotalMessagesForAppUserTopicCount(\n        address app,\n        address user,\n        string calldata topic\n    ) external view returns (uint256) {\n        return\n            getTotalMessagesForHashCount(\n                keccak256(\n                    abi.encodePacked(\n                        APP_USER_TOPIC_HASH_PREFIX,\n                        app,\n                        user,\n                        topic\n                    )\n                )\n            );\n    }\n}\n"},"lib/solady/src/tokens/ERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC1155 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC1155.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155/ERC1155.sol)\n///\n/// @dev Note:\n/// - The ERC1155 standard allows for self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The transfer functions use the identity precompile (0x4)\n///   to copy memory internally.\n///\n/// If you are overriding:\n/// - Make sure all variables written to storage are properly cleaned\n//    (e.g. the bool value for `isApprovedForAll` MUST be either 1 or 0 under the hood).\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC1155 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The lengths of the input arrays are not the same.\n    error ArrayLengthsMismatch();\n\n    /// @dev Cannot mint or transfer to the zero address.\n    error TransferToZeroAddress();\n\n    /// @dev The recipient's balance has overflowed.\n    error AccountBalanceOverflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Only the token owner or an approved account can manage the tokens.\n    error NotOwnerNorApproved();\n\n    /// @dev Cannot safely transfer to a contract that does not implement\n    /// the ERC1155Receiver interface.\n    error TransferToNonERC1155ReceiverImplementer();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when `amount` of token `id` is transferred\n    /// from `from` to `to` by `operator`.\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    /// @dev Emitted when `amounts` of token `ids` are transferred\n    /// from `from` to `to` by `operator`.\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\n\n    /// @dev Emitted when the Uniform Resource Identifier (URI) for token `id`\n    /// is updated to `value`. This event is not used in the base contract.\n    /// You may need to emit this event depending on your URI logic.\n    ///\n    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata\n    event URI(string value, uint256 indexed id);\n\n    /// @dev `keccak256(bytes(\"TransferSingle(address,address,address,uint256,uint256)\"))`.\n    uint256 private constant _TRANSFER_SINGLE_EVENT_SIGNATURE =\n        0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62;\n\n    /// @dev `keccak256(bytes(\"TransferBatch(address,address,address,uint256[],uint256[])\"))`.\n    uint256 private constant _TRANSFER_BATCH_EVENT_SIGNATURE =\n        0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb;\n\n    /// @dev `keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`.\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `ownerSlotSeed` of a given owner is given by.\n    /// ```\n    ///     let ownerSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner))\n    /// ```\n    ///\n    /// The balance slot of `owner` is given by.\n    /// ```\n    ///     mstore(0x20, ownerSlotSeed)\n    ///     mstore(0x00, id)\n    ///     let balanceSlot := keccak256(0x00, 0x40)\n    /// ```\n    ///\n    /// The operator approval slot of `owner` is given by.\n    /// ```\n    ///     mstore(0x20, ownerSlotSeed)\n    ///     mstore(0x00, operator)\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ERC1155_MASTER_SLOT_SEED = 0x9a31110384e0b0c9;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC1155 METADATA                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the URI for token `id`.\n    ///\n    /// You can either return the same templated URI for all token IDs,\n    /// (e.g. \"https://example.com/api/{id}.json\"),\n    /// or return a unique URI for each `id`.\n    ///\n    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          ERC1155                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the amount of `id` owned by `owner`.\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            result := sload(keccak256(0x00, 0x40))\n        }\n    }\n\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.\n    ///\n    /// Emits a {ApprovalForAll} event.\n    function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-line\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }\n\n    /// @dev Transfers `amount` of `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `from` must have at least `amount` of `id`.\n    /// - If the caller is not `from`,\n    ///   it must be approved to manage the tokens of `from`.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, toSlotSeed)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155Received} check if `to` is a smart contract.\n            if extcodesize(to) {\n                // Prepare the calldata.\n                let m := mload(0x40)\n                // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n                mstore(m, 0xf23a6e61)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                mstore(add(m, 0x60), id)\n                mstore(add(m, 0x80), amount)\n                mstore(add(m, 0xa0), 0xa0)\n                calldatacopy(add(m, 0xc0), sub(data.offset, 0x20), add(0x20, data.length))\n                // Revert if the call reverts.\n                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Transfers `amounts` of `ids` from `from` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `from` must have at least `amount` of `id`.\n    /// - `ids` and `amounts` must have the same length.\n    /// - If the caller is not `from`,\n    ///   it must be approved to manage the tokens of `from`.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {TransferBatch} event.\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, amounts.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, ids.length) } i {} {\n                    i := sub(i, 0x20)\n                    let amount := calldataload(add(amounts.offset, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, calldataload(add(ids.offset, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, ids.length))\n                let o := add(m, 0x40)\n                calldatacopy(o, sub(ids.offset, 0x20), n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, n))\n                calldatacopy(add(o, n), sub(amounts.offset, 0x20), n)\n                // Do the emit.\n                log4(m, add(add(n, n), 0x40), _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransferCalldata(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.\n            if extcodesize(to) {\n                mstore(0x00, to) // Cache `to` to prevent stack too deep.\n                let m := mload(0x40)\n                // Prepare the calldata.\n                // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n                mstore(m, 0xbc197c81)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                // Copy the `ids`.\n                mstore(add(m, 0x60), 0xa0)\n                let n := add(0x20, shl(5, ids.length))\n                let o := add(m, 0xc0)\n                calldatacopy(o, sub(ids.offset, 0x20), n)\n                // Copy the `amounts`.\n                let s := add(0xa0, n)\n                mstore(add(m, 0x80), s)\n                calldatacopy(add(o, n), sub(amounts.offset, 0x20), n)\n                // Copy the `data`.\n                mstore(add(m, 0xa0), add(s, n))\n                calldatacopy(add(o, add(n, n)), sub(data.offset, 0x20), add(0x20, data.length))\n                let nAll := add(0xc4, add(data.length, add(n, n)))\n                // Revert if the call reverts.\n                if iszero(call(gas(), mload(0x00), 0, add(m, 0x1c), nAll, m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the amounts of `ids` for `owners.\n    ///\n    /// Requirements:\n    /// - `owners` and `ids` must have the same length.\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, owners.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            balances := mload(0x40)\n            mstore(balances, ids.length)\n            let o := add(balances, 0x20)\n            let i := shl(5, ids.length)\n            mstore(0x40, add(i, o))\n            // Loop through all the `ids` and load the balances.\n            for {} i {} {\n                i := sub(i, 0x20)\n                let owner := calldataload(add(owners.offset, i))\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))\n                mstore(0x00, calldataload(add(ids.offset, i)))\n                mstore(add(o, i), sload(keccak256(0x00, 0x40)))\n            }\n        }\n    }\n\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// See: https://eips.ethereum.org/EIPS/eip-165\n    /// This function call must use less than 30000 gas.\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Mints `amount` of `id` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n                mstore(0x14, to)\n                mstore(0x00, id)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);\n    }\n\n    /// @dev Mints `amounts` of `ids` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `ids` and `amounts` must have the same length.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {TransferBatch} event.\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `_burn(address(0), from, id, amount)`.\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _burn(address(0), from, id, amount);\n    }\n\n    /// @dev Destroys `amount` of `id` from `from`.\n    ///\n    /// Requirements:\n    /// - `from` must have at least `amount` of `id`.\n    /// - If `by` is not the zero address, it must be either `from`,\n    ///   or approved to manage the tokens of `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            if iszero(or(iszero(shl(96, by)), eq(shl(96, by), from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Decrease and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n    }\n\n    /// @dev Equivalent to `_batchBurn(address(0), from, ids, amounts)`.\n    function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        _batchBurn(address(0), from, ids, amounts);\n    }\n\n    /// @dev Destroys `amounts` of `ids` from `from`.\n    ///\n    /// Requirements:\n    /// - `ids` and `amounts` must have the same length.\n    /// - `from` must have at least `amounts` of `ids`.\n    /// - If `by` is not the zero address, it must be either `from`,\n    ///   or approved to manage the tokens of `from`.\n    ///\n    /// Emits a {TransferBatch} event.\n    function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Decrease and store the updated balance of `from`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL APPROVAL FUNCTIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Approve or remove the `operator` as an operator for `by`,\n    /// without authorization checks.\n    ///\n    /// Emits a {ApprovalForAll} event.\n    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, by)\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            let m := shr(96, not(0))\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, and(m, by), and(m, operator))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `_safeTransfer(address(0), from, to, id, amount, data)`.\n    function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)\n        internal\n        virtual\n    {\n        _safeTransfer(address(0), from, to, id, amount, data);\n    }\n\n    /// @dev Transfers `amount` of `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `from` must have at least `amount` of `id`.\n    /// - If `by` is not the zero address, it must be either `from`,\n    ///   or approved to manage the tokens of `from`.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _safeTransfer(\n        address by,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);\n    }\n\n    /// @dev Equivalent to `_safeBatchTransfer(address(0), from, to, ids, amounts, data)`.\n    function _safeBatchTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _safeBatchTransfer(address(0), from, to, ids, amounts, data);\n    }\n\n    /// @dev Transfers `amounts` of `ids` from `from` to `to`.\n    ///\n    /// Requirements:\n    /// - `to` cannot be the zero address.\n    /// - `ids` and `amounts` must have the same length.\n    /// - `from` must have at least `amounts` of `ids`.\n    /// - If `by` is not the zero address, it must be either `from`,\n    ///   or approved to manage the tokens of `from`.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.\n    ///\n    /// Emits a {TransferBatch} event.\n    function _safeBatchTransfer(\n        address by,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, from_)\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, to_)\n            mstore(0x20, fromSlotSeed)\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    HOOKS FOR OVERRIDING                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Override this function to return true if `_beforeTokenTransfer` is used.\n    /// This is to help the compiler avoid producing dead bytecode.\n    function _useBeforeTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }\n\n    /// @dev Hook that is called before any token transfer.\n    /// This includes minting and burning, as well as batched variants.\n    ///\n    /// The same hook is called on both single and batched variants.\n    /// For single transfers, the length of the `id` and `amount` arrays are 1.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /// @dev Override this function to return true if `_afterTokenTransfer` is used.\n    /// This is to help the compiler avoid producing dead bytecode.\n    function _useAfterTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }\n\n    /// @dev Hook that is called after any token transfer.\n    /// This includes minting and burning, as well as batched variants.\n    ///\n    /// The same hook is called on both single and batched variants.\n    /// For single transfers, the length of the `id` and `amount` arrays are 1.\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Helper for calling the `_afterTokenTransfer` hook.\n    /// This is to help the compiler avoid producing dead bytecode.\n    function _afterTokenTransferCalldata(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) private {\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n    }\n\n    /// @dev Returns if `a` has bytecode of non-zero length.\n    function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }\n\n    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155Received} on `to`.\n    /// Reverts if the target does not support the function correctly.\n    function _checkOnERC1155Received(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            mstore(m, 0xf23a6e61)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), amount)\n            mstore(add(m, 0xa0), 0xa0)\n            let n := mload(data)\n            mstore(add(m, 0xc0), n)\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xe0), n)) }\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155BatchReceived} on `to`.\n    /// Reverts if the target does not support the function correctly.\n    function _checkOnERC1155BatchReceived(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            mstore(m, 0xbc197c81)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            // Copy the `ids`.\n            mstore(add(m, 0x60), 0xa0)\n            let n := add(0x20, shl(5, mload(ids)))\n            let o := add(m, 0xc0)\n            pop(staticcall(gas(), 4, ids, n, o, n))\n            // Copy the `amounts`.\n            let s := add(0xa0, returndatasize())\n            mstore(add(m, 0x80), s)\n            o := add(o, returndatasize())\n            n := add(0x20, shl(5, mload(amounts)))\n            pop(staticcall(gas(), 4, amounts, n, o, n))\n            // Copy the `data`.\n            mstore(add(m, 0xa0), add(s, returndatasize()))\n            o := add(o, returndatasize())\n            n := add(0x20, mload(data))\n            pop(staticcall(gas(), 4, data, n, o, n))\n            n := sub(add(o, returndatasize()), add(m, 0x1c))\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns `x` in an array with a single element.\n    function _single(uint256 x) private pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x40, add(result, 0x40))\n            mstore(result, 1)\n            mstore(add(result, 0x20), x)\n        }\n    }\n}\n"},"lib/solady/src/utils/Base64.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                let dataEnd := add(add(0x20, data), dataLength)\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n"},"lib/solady/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success :=\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x34, 0) // Store 0 for the `amount`.\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                mstore(0x34, amount) // Store back the original `amount`.\n                // Retry the approval, reverting upon failure.\n                if iszero(\n                    and(\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n                ) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(mul(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), extcodesize(p)))\n            {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"src/apps/inscribed-drops/TwoStepOwnable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * @notice A two-step extension of Ownable, where the new owner must claim ownership of the contract after owner\n * initiates transfer\n * Owner can cancel the transfer at any point before the new owner claims ownership.\n * Helpful in guarding against transferring ownership to an address that is unable to act as the Owner.\n */\nabstract contract TwoStepOwnable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    address internal potentialOwner;\n\n    event PotentialOwnerUpdated(address newPotentialAdministrator);\n\n    error NewOwnerIsZeroAddress();\n    error NotNextOwner();\n    error OnlyOwner();\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    ///@notice Initiate ownership transfer to newPotentialOwner. Note: new owner will have to manually acceptOwnership\n    ///@param newPotentialOwner address of potential new owner\n    function transferOwnership(address newPotentialOwner) public virtual onlyOwner {\n        if (newPotentialOwner == address(0)) {\n            revert NewOwnerIsZeroAddress();\n        }\n        potentialOwner = newPotentialOwner;\n        emit PotentialOwnerUpdated(newPotentialOwner);\n    }\n\n    ///@notice Claim ownership of smart contract, after the current owner has initiated the process with\n    /// transferOwnership\n    function acceptOwnership() public virtual {\n        address _potentialOwner = potentialOwner;\n        if (msg.sender != _potentialOwner) {\n            revert NotNextOwner();\n        }\n        delete potentialOwner;\n        emit PotentialOwnerUpdated(address(0));\n        _transferOwnership(_potentialOwner);\n    }\n\n    ///@notice cancel ownership transfer\n    function cancelOwnershipTransfer() public virtual onlyOwner {\n        delete potentialOwner;\n        emit PotentialOwnerUpdated(address(0));\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (_owner != msg.sender) {\n            revert OnlyOwner();\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"lib/solady/src/utils/LibString.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// @dev Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\n        return indexOf(subject, search) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n)\n            let o := add(result, 0x20)\n            mstore(o, s)\n            mstore(add(o, n), 0)\n            mstore(0x40, add(result, 0x40))\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"},"src/net/EventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 .0;\n\ninterface EventsAndErrors {\n    error MsgEmpty();\n    error InvalidRange();\n    error InvalidStartIndex();\n    error InvalidEndIndex();\n\n    event MessageSent(\n        address indexed sender,\n        string indexed topic,\n        uint256 messageIndex\n    );\n\n    event MessageSentViaApp(\n        address indexed app,\n        address indexed sender,\n        string indexed topic,\n        uint256 messageIndex\n    );\n}\n"},"src/net/INet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 .0;\n\ninterface INet {\n    struct Message {\n        address app;\n        address sender;\n        uint256 timestamp;\n        bytes data;\n        string text;\n        string topic;\n    }\n\n    function sendMessageViaApp(\n        address sender,\n        string calldata text,\n        string calldata topic,\n        bytes calldata extraData\n    ) external;\n\n    function sendMessage(\n        string calldata text,\n        string calldata topic,\n        bytes calldata extraData\n    ) external;\n\n    // **************\n    // Fetch Messages\n    // **************\n\n    // Fetch message indexes\n\n    function getMessageIdxForApp(\n        uint256 idx,\n        address app\n    ) external view returns (uint256);\n\n    function getMessageIdxForAppUser(\n        uint256 idx,\n        address app,\n        address user\n    ) external view returns (uint256);\n\n    function getMessageIdxForAppTopic(\n        uint256 idx,\n        address app,\n        string calldata topic\n    ) external view returns (uint256);\n\n    function getMessageIdxForAppUserTopic(\n        uint256 idx,\n        address app,\n        address user,\n        string calldata topic\n    ) external view returns (uint256);\n\n    // Fetch single message\n\n    function getMessage(uint256 idx) external view returns (Message memory);\n\n    function getMessageForApp(\n        uint256 idx,\n        address app\n    ) external view returns (Message memory);\n\n    function getMessageForAppUser(\n        uint256 idx,\n        address app,\n        address user\n    ) external view returns (Message memory);\n\n    function getMessageForAppTopic(\n        uint256 idx,\n        address app,\n        string calldata topic\n    ) external view returns (Message memory);\n\n    function getMessageForAppUserTopic(\n        uint256 idx,\n        address app,\n        address user,\n        string calldata topic\n    ) external view returns (Message memory);\n\n    // Fetch multiple messages\n\n    function getMessagesInRange(\n        uint256 startIdx,\n        uint256 endIdx\n    ) external view returns (Message[] memory);\n\n    function getMessagesInRangeForApp(\n        uint256 startIdx,\n        uint256 endIdx,\n        address app\n    ) external view returns (Message[] memory);\n\n    function getMessagesInRangeForAppUser(\n        uint256 startIdx,\n        uint256 endIdx,\n        address app,\n        address user\n    ) external view returns (Message[] memory);\n\n    function getMessagesInRangeForAppTopic(\n        uint256 startIdx,\n        uint256 endIdx,\n        address app,\n        string calldata topic\n    ) external view returns (Message[] memory);\n\n    function getMessagesInRangeForAppUserTopic(\n        uint256 startIdx,\n        uint256 endIdx,\n        address app,\n        address user,\n        string calldata topic\n    ) external view returns (Message[] memory);\n\n    // **************\n    // Message counts\n    // **************\n\n    function getTotalMessagesCount() external view returns (uint256);\n\n    function getTotalMessagesForAppCount(\n        address app\n    ) external view returns (uint256);\n\n    function getTotalMessagesForAppUserCount(\n        address app,\n        address user\n    ) external view returns (uint256);\n\n    function getTotalMessagesForAppTopicCount(\n        address app,\n        string calldata topic\n    ) external view returns (uint256);\n\n    function getTotalMessagesForAppUserTopicCount(\n        address app,\n        address user,\n        string calldata topic\n    ) external view returns (uint256);\n}\n"},"lib/solady/src/utils/SSTORE2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev We skip the first byte as it's a STOP opcode,\n    /// which ensures the contract can't be called.\n    uint256 internal constant DATA_OFFSET = 1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /// @dev The storage contract address is invalid.\n    error InvalidPointer();\n\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\n    error ReadOutOfBounds();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            /**\n             * ------------------------------------------------------------------------------+\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\n             * ------------------------------------------------------------------------------|\n             * 61 dataSize | PUSH2 dataSize  | dataSize                |                     |\n             * 80          | DUP1            | dataSize dataSize       |                     |\n             * 60 0xa      | PUSH1 0xa       | 0xa dataSize dataSize   |                     |\n             * 3D          | RETURNDATASIZE  | 0 0xa dataSize dataSize |                     |\n             * 39          | CODECOPY        | dataSize                | [0..dataSize): code |\n             * 3D          | RETURNDATASIZE  | 0 dataSize              | [0..dataSize): code |\n             * F3          | RETURN          |                         | [0..dataSize): code |\n             * 00          | STOP            |                         |                     |\n             * ------------------------------------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            mstore(\n                // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\n                // The actual EVM limit may be smaller and may change over time.\n                add(data, gt(dataSize, 0xffff)),\n                // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                or(0xfd61000080600a3d393df300, shl(0x40, dataSize))\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its deterministic address.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(\n                // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\n                // The actual EVM limit may be smaller and may change over time.\n                add(data, gt(dataSize, 0xffff)),\n                // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                or(0xfd61000080600a3d393df300, shl(0x40, dataSize))\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(dataSize, 0xa), salt)\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), shr(16, dataSize))\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            hash := keccak256(add(data, 0x15), add(dataSize, 0xa))\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         READ LOGIC                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Offset all indices by 1 to skip the STOP opcode.\n            let size := sub(pointerCodesize, DATA_OFFSET)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), DATA_OFFSET, size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the end of the data stored.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > start)`, reverts.\n            // This also handles the case where `start + DATA_OFFSET` overflows.\n            if iszero(gt(pointerCodesize, start)) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(pointerCodesize, add(start, DATA_OFFSET))\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\n            // This also handles the cases where\n            // `end + DATA_OFFSET` or `start + DATA_OFFSET` overflows.\n            if iszero(\n                and(\n                    gt(pointerCodesize, end), // Within bounds.\n                    iszero(gt(start, end)) // Valid range.\n                )\n            ) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(end, start)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n}\n"}},"settings":{"remappings":["@prb/test/=lib/prb-test/src/","forge-std/=lib/forge-std/src/","src/=src/","@erc721a/=lib/ERC721A/contracts/","@openzeppelin/=lib/openzeppelin-contracts/","openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/","@solady/=lib/solady/src/","solmate/=lib/solady/lib/solmate/src/","utility-contracts/=lib/utility-contracts/src/","@seaport-types/=lib/seaport-types/src/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","ERC721A/=lib/ERC721A/contracts/","ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","prb-math/=lib/prb-math/src/","prb-test/=lib/prb-test/src/","seaport-types/=lib/seaport-types/src/","solady/=lib/solady/src/"],"optimizer":{"enabled":true,"runs":20},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":false},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}

<html>
  <body style="margin: 0">
    <svg id="root" viewBox="0 0 400 400" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
      <rect x="0" y="0" width="100%" height="100%" fill="rgba(0,0,0,1)" />
    </svg>
    <script>
      function random_rgba() {
        var o = Math.round,
          r = Math.random,
          s = 255;
        return `hsl(${Math.random() * 360},100%,60%)`; //lightgreen
      }

      const images = [
        // Red ring
        "PHN2ZwogIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICB3aWR0aD0iMTAwJSIKICBoZWlnaHQ9IjEwMCUiCiAgdmlld0JveD0iMCAwIDQwMCA0MDAiCiAgc3R5bGU9ImJhY2tncm91bmQ6ICMwMDA7IGRpc3BsYXk6IGJsb2NrOyBtYXJnaW46IGF1dG8iCj4KICA8Y2lyY2xlIGN4PSIyMDAiIGN5PSIyMDAiIHI9IjE1MCIgc3Ryb2tlPSJyZWQiIHN0cm9rZS13aWR0aD0iMjUiPjwvY2lyY2xlPgo8L3N2Zz4K",
      ];

      const CONTENT_INTERVAL = 3;

      const contents = [];
      for (let i = 0; i < 0; i++) {
        contents.push("message" + i);
        contents.push("sender" + i);
        contents.push("topic" + i);
      }

      let s = async (ms) => new Promise((resolve) => setTimeout(resolve, ms));

      async function writeText() {
        const textItems = Array.from(document.getElementsByTagName("text"));
        const ogText = textItems.map((textItem) => textItem.textContent);
        textItems.forEach((textItem) => (textItem.textContent = ""));

        const pfpItems = Array.from(document.getElementsByTagName("image"));
        pfpItems.forEach((pfp) => pfp.setAttributeNS(null, "visibility", "hidden"));
        for (let i = 0; i < textItems.length; i++) {
          let txt = ogText[i];
          if (i % 2 === 0) {
            // divided by two since there's two text items for each pfp
            pfpItems[i / 2].setAttributeNS(null, "visibility", "visible");
          }
          for (let j = 0; j <= txt.length; j++) {
            textItems[i].textContent = txt.substring(0, j);
            await s(1);
          }
        }
      }

      let SVG_HEIGHT = 400;
      let MSGS_TO_SHOW_AT_ONCE = 18;
      let START_MSGS_IDX = contents.length - MSGS_TO_SHOW_AT_ONCE * CONTENT_INTERVAL;

      async function addElements() {
        const svg = document.getElementById("root");

        let currY = 22;
        let currImgY = 3;
        let currTxtY = 18;
        let yInterval = SVG_HEIGHT / MSGS_TO_SHOW_AT_ONCE; //400 / 22;
        let senderTxtY = 6;
        for (
          let i = START_MSGS_IDX;
          i < START_MSGS_IDX + MSGS_TO_SHOW_AT_ONCE * CONTENT_INTERVAL && i < contents.length;
          i += CONTENT_INTERVAL
        ) {
          const useDefaultPfp = true; //Math.random() < 0.4;
          const color = useDefaultPfp ? "pink" : random_rgba();

          // Only add elements if i>=0 but still update all Y values at end if i is less than 0 so we properly offet all the elements that will get added later
          if (i >= 0) {
            var pfp = document.createElementNS("http://www.w3.org/2000/svg", "image");
            // Need to set large and scale down cause otherwise it shows with weird gray strokes
            pfp.setAttributeNS(null, "height", "300px");
            pfp.setAttributeNS(null, "width", "300px");
            pfp.setAttributeNS(null, "transform", `translate(2,${currImgY}) scale(0.05)`);
            pfp.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "href",
              `data:image/svg+xml;base64,${
                useDefaultPfp
                  ? // Placeholder
                    images[0]
                  : // Random actual image or placeholder
                    images[1 + Math.floor(Math.random() * (images.length - 1))]
              }`,
            );

            svg.append(pfp);

            var newLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            newLine.setAttribute("x1", "2");
            newLine.setAttribute("x2", "400");
            newLine.setAttribute("y1", currY);
            newLine.setAttribute("y2", currY);
            newLine.setAttribute("stroke", color);
            newLine.setAttribute("stroke-width", "0.3px");
            svg.append(newLine);

            const [message, sender, topic] = [contents[i], contents[i + 1], contents[i + 2]];

            var senderTxt = document.createElementNS("http://www.w3.org/2000/svg", "text");
            senderTxt.setAttribute("style", "font-family: monospace; font-size: 6px");
            senderTxt.setAttribute("x", "20");
            senderTxt.setAttribute("y", senderTxtY);
            senderTxt.setAttribute("fill", color);
            senderTxt.textContent = `<name> | ${topic} | ${sender}`;
            svg.append(senderTxt);

            var newText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            newText.setAttribute("style", "font-family: monospace; font-size: 9px");
            // TODO don't allow text to go over edge
            newText.setAttribute("x", "20");
            newText.setAttribute("y", currTxtY);
            newText.setAttribute("fill", color);
            newText.textContent = message;
            svg.append(newText);
          }

          // TODO Consolidate into a single Y with offsets
          currY += yInterval;
          currTxtY += yInterval;
          senderTxtY += yInterval;
          currImgY += yInterval;
        }
      }

      function clear(tagName) {
        Array.from(document.getElementsByTagName(tagName)).forEach(function (item) {
          item.parentNode.removeChild(item);
        });
      }
      async function removeElements() {
        clear("image");
        clear("text");
        clear("line");
      }

      async function refresh() {
        await removeElements();
        await addElements();
        await writeText();
      }

      refresh();

      let cursorPoint = (evt) => {
        var pt = document.getElementById("root").createSVGPoint();
        pt.x = evt.clientX;
        pt.y = evt.clientY;
        return pt.matrixTransform(document.getElementById("root").getScreenCTM().inverse());
      };
      document.body.addEventListener("click", async (e) => {
        const clickTarget = e.target;
        const point = cursorPoint(e);
        console.log(point, document.getElementById("root").getAttribute("height"));
        let changed = false;
        if (point.y > SVG_HEIGHT / 2) {
          if (START_MSGS_IDX + MSGS_TO_SHOW_AT_ONCE < contents.length) {
            // TODO confirm the check is right here
            START_MSGS_IDX += MSGS_TO_SHOW_AT_ONCE;
            changed = true;
          }
        } else {
          if (START_MSGS_IDX > 0) {
            START_MSGS_IDX -= MSGS_TO_SHOW_AT_ONCE;
            changed = true;
          }
        }
        changed && (await refresh());
      });
    </script>
  </body>
</html>
